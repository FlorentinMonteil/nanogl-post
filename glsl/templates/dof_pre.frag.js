module.exports = function( obj ){
var __t,__p='';
__p+='\nuniform sampler2D tDofMedBlur;\nuniform sampler2D tDofBlur;\nuniform vec2      uDofInvTargetSize;\n\nuniform vec4      uDofLerpScale;\nuniform vec4      uDofLerpBias;\nuniform vec3      uDofEqFar;\n\n\nvec3 GetSmallBlurSample( vec2 texCoords )\n{\n  vec3 sum;\n  const float weight = 4.0 / 17.0;\n  sum  = weight * texture2D( tInput, texCoords + vec2(+0.5, -1.5)*uDofInvTargetSize ).rgb;\n  sum += weight * texture2D( tInput, texCoords + vec2(-1.5, -0.5)*uDofInvTargetSize ).rgb;\n  sum += weight * texture2D( tInput, texCoords + vec2(-0.5, +1.5)*uDofInvTargetSize ).rgb;\n  sum += weight * texture2D( tInput, texCoords + vec2(+1.5, +0.5)*uDofInvTargetSize ).rgb;\n  return sum;\n}\n\n\n\nvoid InterpolateDof( inout vec3 c, mediump vec3 small, mediump vec3 med, mediump vec3 large, mediump float coc )\n{\n  mediump vec4  weights;\n  mediump vec3  color;\n  mediump float alpha;\n\n\n  // small = small*0.0000001 + vec3(1.0, 0.0, 0.0);\n  // med   = med  *0.0000001 + vec3(0.0, 1.0, 0.0);\n  // large = large*0.0000001 + vec3(0.0, 0.0, 1.0);\n\n\n  // Efficiently calculate the cross-blend weights for each sample.\n   // Let the unblurred sample to small blur fade happen over distance\n   // d0, the small to medium blur over distance d1, and the medium to\n   // large blur over distance d2, where d0 + d1 + d2 = 1.\n   // dofLerpScale = float4( -1 / d0, -1 / d1, -1 / d2, 1 / d2 );\n   // dofLerpBias = float4( 1, (1 – d2) / d1, 1 / d2, (d2 – 1) / d2 );\n\n  weights = clamp( coc * uDofLerpScale + uDofLerpBias, 0.0, 1.0 );\n  weights.yz = min( weights.yz, 1.0 - weights.xy );\n\n  // Unblurred sample with weight "weights.x" done by alpha blending\n  color = weights.y * small + weights.z * med + weights.w * large;\n  alpha = 1.0 - dot( weights.yzw, vec3( 16.0 / 17.0, 1.0, 1.0 ) );\n\n  c = c*alpha + color;\n\n  // c = c*0.00000001 + med;\n  // return half4( color, alpha );\n\n}';
return __p;
}